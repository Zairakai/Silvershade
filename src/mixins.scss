@use 'sass:map';
@use 'sass:math';
@use 'sass:color';
@use 'variables' as SylverShadeVariables;
@use 'functions' as SylverShadeFunctions;

/// Mixin to cut corners of an element using a `clip-path` polygon.
/// This mixin allows you to cut corners of an element in a polygonal shape.
///
/// @param {map} $values - A map containing the corner values (`top-left`, `top-right`, `bottom-right`, `bottom-left`).
/// @param {string|null} $symmetry - Optional parameter to define the symmetry of the corners (e.g., `horizontal`, `vertical`).
/// @throws {Error} If an invalid symmetry is provided.
@mixin corners-cut($values, $symmetry: null) {
    $corners: $values;

    @if null != $symmetry {
        $corners: SylverShadeFunctions.corners-cut-symmetry($values, $symmetry);
    }

    $top-left: map.get($corners, top-left, 0);
    $top-right: map.get($corners, top-right, 0);
    $bottom-right: map.get($corners, bottom-right, 0);
    $bottom-left: map.get($corners, bottom-left, 0);

    // prettier-ignore
    clip-path: polygon(
        0 #{SylverShadeFunctions.px-to-rem($top-left, (force-zero-rem: true))},
        #{SylverShadeFunctions.px-to-rem($top-left, (force-zero-rem: true))} 0,
        calc(100% - #{SylverShadeFunctions.px-to-rem($top-right, (force-zero-rem: true))}) 0,
        100% #{SylverShadeFunctions.px-to-rem($top-right, (force-zero-rem: true))},
        100% calc(100% - #{SylverShadeFunctions.px-to-rem($bottom-right, (force-zero-rem: true))}),
        calc(100% - #{SylverShadeFunctions.px-to-rem($bottom-right, (force-zero-rem: true))}) 100%,
        #{SylverShadeFunctions.px-to-rem($bottom-left, (force-zero-rem: true))} 100%,
        0 calc(100% - #{SylverShadeFunctions.px-to-rem($bottom-left, (force-zero-rem: true))})
    );
}

/// Mixin to add elevation (box-shadow) to an element.
/// This mixin applies a box-shadow based on the given elevation level and color.
///
/// @param {number} $elevation - The elevation level (0 or higher).
/// @param {color} $color - The shadow color (default: `#000`).
@mixin elevation($elevation: 0, $color: #000) {
    box-shadow:
        SylverShadeFunctions.px-to-rem(SylverShadeFunctions.get-elevation-value($elevation, 1, 'size'))
            SylverShadeFunctions.color-alpha($color, SylverShadeFunctions.get-elevation-value($elevation, 1, 'alpha')),
        SylverShadeFunctions.px-to-rem(SylverShadeFunctions.get-elevation-value($elevation, 2, 'size'))
            SylverShadeFunctions.color-alpha($color, SylverShadeFunctions.get-elevation-value($elevation, 2, 'alpha')),
        SylverShadeFunctions.px-to-rem(SylverShadeFunctions.get-elevation-value($elevation, 3, 'size'))
            SylverShadeFunctions.color-alpha($color, SylverShadeFunctions.get-elevation-value($elevation, 3, 'alpha'));
}

/// Mixin to handle media queries based on breakpoints and orientation.
/// This mixin generates media queries for responsive design based on breakpoints.
///
/// @param {string|null} $key - A specific breakpoint key to target (optional).
/// @param {string|null} $orientation - The orientation (e.g., `portrait`, `landscape`).
/// @param {string} $range - Range type (e.g., `min`, `max`, `both`).
@mixin media-queries($key: null, $orientation: null, $range: min) {
    // prettier-ignore
    @if $orientation != null and not map.has-key(SylverShadeVariables.$breakpoints, $orientation) {
        @error "Orientation '#{$orientation}' not available. Use 'landscape' or 'portrait'.";
    }

    $breakpoints: if(
        null != $orientation,
        map.get(SylverShadeVariables.$breakpoints, $orientation),
        SylverShadeVariables.$breakpoints
    );

    // Parcours des breakpoints pour chaque orientation
    @if null != $orientation {
        @each $currentKey, $config in $breakpoints {
            @if null != $key {
                @if $currentKey == $key {
                    @include generate-media-query($config, $orientation, $range) {
                        @content;
                    }
                }
            } @else {
                @include generate-media-query($config, $orientation, $range) {
                    @content;
                }
            }
        }
    } @else {
        @each $direction, $sizes in $breakpoints {
            @each $currentKey, $config in $sizes {
                @if null != $key {
                    @if $currentKey == $key {
                        @include generate-media-query($config, $direction, $range) {
                            @content;
                        }
                    }
                } @else {
                    @include generate-media-query($config, $direction, $range) {
                        @content;
                    }
                }
            }
        }
    }
}

/// Helper mixin to generate a media query.
/// This mixin is used to wrap content inside a media query based on breakpoints and orientation.
///
/// @param {map} $config - The breakpoint configuration map (includes `min-width` and `max-width`).
/// @param {string} $direction - Orientation type (`portrait`, `landscape`).
/// @param {string} $range - The range type (`min`, `max`, `both`).
/// @content - Content to be wrapped inside the media query.
@mixin generate-media-query($config, $direction, $range) {
    $media-query: '';

    @if 'min' == $range or 'both' == $range {
        $min-width: SylverShadeFunctions.px-to-rem(map.get($config, min-width));
        $media-query: '#{$media-query} (min-width: #{$min-width})';
    }

    @if 'max' == $range or 'both' == $range {
        @if '' != $media-query {
            $media-query: '#{$media-query} and ';
        }

        $max-width: SylverShadeFunctions.px-to-rem(map.get($config, max-width));
        $media-query: '#{$media-query}(max-width: #{$max-width})';
    }

    $media-query: '#{$media-query} and (orientation: #{$direction})';

    @media #{$media-query} {
        @content;
    }
}

/// Mixin to apply a specific shape to an element using border-radius.
/// This mixin allows you to apply different shapes (e.g., circle, rounded) to elements.
///
/// @param {string} $shape - The shape name (e.g., `circle`, `rounded`).
/// @param {string|null} $cornerOrSide - A specific corner or side to apply the shape (optional).
/// @throws {Error} If an invalid corner or side is provided.
@mixin shape($shape, $cornerOrSide: null) {
    $radius: if(
        map.has-key(SylverShadeVariables.$shape-radius, $shape),
        map.get(SylverShadeVariables.$shape-radius, $shape),
        $shape
    );

    @if '%' != math.unit($radius) {
        $radius: SylverShadeFunctions.px-to-rem($radius);
    }

    $top-left: 0;
    $top-right: 0;
    $bottom-left: 0;
    $bottom-right: 0;

    @if 'top-left' == $cornerOrSide {
        $top-left: $radius;
    } @else if 'top-right' == $cornerOrSide {
        $top-right: $radius;
    } @else if 'bottom-left' == $cornerOrSide {
        $bottom-left: $radius;
    } @else if 'bottom-right' == $cornerOrSide {
        $bottom-right: $radius;
    } @else if 'top' == $cornerOrSide {
        $top-left: $radius;
        $top-right: $radius;
    } @else if 'right' == $cornerOrSide {
        $top-right: $radius;
        $bottom-right: $radius;
    } @else if 'bottom' == $cornerOrSide {
        $bottom-left: $radius;
        $bottom-right: $radius;
    } @else if 'left' == $cornerOrSide {
        $top-left: $radius;
        $bottom-left: $radius;
    } @else if null == $cornerOrSide {
        $top-left: $radius;
        $top-right: $radius;
        $bottom-right: $radius;
        $bottom-left: $radius;
    } @else {
        @error "Invalid direction `#{$cornerOrSide}`. Valid directions are: top, right, bottom, left, top-right, bottom-right, bottom-left, top-left.";
    }

    border-radius: $top-left $top-right $bottom-right $bottom-left;
}

/// Mixin to create a triangle using borders.
/// This mixin creates a triangle shape using CSS borders and can be used for indicators, pointers, etc.
///
/// @param {string} $direction - The triangle direction (e.g., `up`, `right`, `down`, `left`, `top-right`, `bottom-right`, `bottom-left`, `top-left`.
/// @param {number} $size - The size of the triangle in pixels.
/// @param {color} $color - The triangle color (default: `currentColor`).
/// @throws {Error} If an invalid direction is provided.
@mixin triangle($direction, $size, $color: currentColor) {
    width: 0;
    height: 0;

    @if 'up' == $direction {
        border-left: SylverShadeFunctions.px-to-rem(math.div($size, 2)) solid transparent;
        border-right: SylverShadeFunctions.px-to-rem(math.div($size, 2)) solid transparent;
        border-bottom: SylverShadeFunctions.px-to-rem($size) solid $color;
    } @else if 'right' == $direction {
        border-top: SylverShadeFunctions.px-to-rem(math.div($size, 2)) solid transparent;
        border-bottom: SylverShadeFunctions.px-to-rem(math.div($size, 2)) solid transparent;
        border-left: SylverShadeFunctions.px-to-rem($size) solid $color;
    } @else if 'down' == $direction {
        border-left: SylverShadeFunctions.px-to-rem(math.div($size, 2)) solid transparent;
        border-right: SylverShadeFunctions.px-to-rem(math.div($size, 2)) solid transparent;
        border-top: SylverShadeFunctions.px-to-rem($size) solid $color;
    } @else if 'left' == $direction {
        border-top: SylverShadeFunctions.px-to-rem(math.div($size, 2)) solid transparent;
        border-bottom: SylverShadeFunctions.px-to-rem(math.div($size, 2)) solid transparent;
        border-right: SylverShadeFunctions.px-to-rem($size) solid $color;
    } @else if 'top-right' == $direction {
        border-bottom: SylverShadeFunctions.px-to-rem($size) solid $color;
        border-left: SylverShadeFunctions.px-to-rem($size) solid transparent;
    } @else if 'bottom-right' == $direction {
        border-top: SylverShadeFunctions.px-to-rem($size) solid $color;
        border-left: SylverShadeFunctions.px-to-rem($size) solid transparent;
    } @else if 'bottom-left' == $direction {
        border-top: SylverShadeFunctions.px-to-rem($size) solid $color;
        border-right: SylverShadeFunctions.px-to-rem($size) solid transparent;
    } @else if 'top-left' == $direction {
        border-bottom: SylverShadeFunctions.px-to-rem($size) solid $color;
        border-right: SylverShadeFunctions.px-to-rem($size) solid transparent;
    } @else {
        @error "Invalid direction `#{$direction}`. Valid directions are: up, right, down, left, top-right, bottom-right, bottom-left, top-left.";
    }
}

/// Mixin to create a flexible layout using Flexbox.
/// This mixin sets up a flex container with customizable direction, alignment, and wrapping properties.
///
/// @param {string} $direction - Flex direction (e.g., `row`, `column`). Default is `row`.
/// @param {string} $justify - Justification of flex items (e.g., `flex-start`, `center`). Default is `flex-start`.
/// @param {string} $align - Alignment of flex items (e.g., `stretch`, `center`). Default is `stretch`.
/// @param {string} $wrap - Wrapping behavior for flex items (e.g., `nowrap`, `wrap`). Default is `nowrap`.
@mixin flexbox($direction: row, $justify: flex-start, $align: stretch, $wrap: nowrap) {
    display: flex;
    justify-content: $justify;
    align-items: $align;
    flex-flow: $direction $wrap;
}

/// Mixin to create a responsive grid layout.
/// This mixin generates a grid with customizable columns and gaps, suitable for responsive designs.
///
/// @param {number} $columns - Number of columns (default is `$default-grid-columns`).
/// @param {string|number} $gap - Gap size (default is small spacing using `get-spacing()` function).
@mixin grid($columns: SylverShadeVariables.$default-grid-columns, $gap: SylverShadeFunctions.get-spacing('sm', true)) {
    display: grid;
    grid-template-columns: repeat($columns, 1fr);
    grid-template-rows: auto;
    gap: SylverShadeFunctions.px-to-rem($gap);
}

/// Mixin to add padding to an element.
/// This mixin sets padding values based on a provided map for each side (top, right, bottom, left).
///
/// @param {map} $spacings - Map with padding values for each side (top, right, bottom, left).
@mixin padding($spacings) {
    $top: map.get($spacings, top, 0);
    $right: map.get($spacings, right, 0);
    $bottom: map.get($spacings, bottom, $top);
    $left: map.get($spacings, left, $right);

    padding: SylverShadeFunctions.px-to-rem($top $right $bottom $left);
}

/// Mixin to generate utility classes for padding and margin based on a given property and value.
/// This mixin creates responsive utility classes for different sides of an element (top, right, bottom, left).
///
/// @param {string} $key - The key for the spacing (e.g., `small`, `medium`, `large`).
/// @param {string|number} $value - The value for the spacing (in pixels, rem, etc.).
/// @param {string} $placeholder - The CSS property for spacing (e.g., `p`, `m`).
/// @param {string} $property - The CSS property for spacing (e.g., `padding`, `margin`).
@mixin generate-spacing-utilities($key, $value, $placeholder, $property) {
    /// Generate the class for all sides (padding or margin)
    %#{$placeholder}-#{$key} {
        #{$property}: SylverShadeFunctions.px-to-rem($value);
    }

    /// Generate the class for the top side (padding-top or margin-top)
    %#{$placeholder}t-#{$key} {
        #{$property}-top: SylverShadeFunctions.px-to-rem($value);
    }

    /// Generate the class for the right side (padding-right or margin-right)
    %#{$placeholder}r-#{$key} {
        #{$property}-right: SylverShadeFunctions.px-to-rem($value);
    }

    /// Generate the class for the bottom side (padding-bottom or margin-bottom)
    %#{$placeholder}b-#{$key} {
        #{$property}-bottom: SylverShadeFunctions.px-to-rem($value);
    }

    /// Generate the class for the left side (padding-left or margin-left)
    %#{$placeholder}l-#{$key} {
        #{$property}-left: SylverShadeFunctions.px-to-rem($value);
    }

    /// Generate the class for vertical sides (top and bottom)
    %#{$placeholder}v-#{$key} {
        #{$property}-top: SylverShadeFunctions.px-to-rem($value);
        #{$property}-bottom: SylverShadeFunctions.px-to-rem($value);
    }

    /// Generate the class for horizontal sides (left and right)
    %#{$placeholder}h-#{$key} {
        #{$property}-right: SylverShadeFunctions.px-to-rem($value);
        #{$property}-left: SylverShadeFunctions.px-to-rem($value);
    }
}

/// Mixin to add padding to an element.
@mixin p($key, $direction: null) {
    $value: if(map.has-key(SylverShadeVariables.$spacings, $key), map.get(SylverShadeVariables.$spacings, $key), 0);
    $value: SylverShadeFunctions.px-to-rem($value);

    @if 't' == $direction {
        padding-top: $value;
    } @else if 'r' == $direction {
        padding-right: $value;
    } @else if 'b' == $direction {
        padding-bottom: $value;
    } @else if 'l' == $direction {
        padding-left: $value;
    } @else if 'v' == $direction {
        padding-top: $value;
        padding-bottom: $value;
    } @else if 'h' == $direction {
        padding-right: $value;
        padding-left: $value;
    } @else {
        padding: $value;
    }
}

/// Mixin to add padding to an element.
@mixin m($key, $direction: null) {
    $value: if(map.has-key(SylverShadeVariables.$spacings, $key), map.get(SylverShadeVariables.$spacings, $key), 0);
    $value: SylverShadeFunctions.px-to-rem($value);

    @if 't' == $direction {
        margin-top: $value;
    } @else if 'r' == $direction {
        margin-right: $value;
    } @else if 'b' == $direction {
        margin-bottom: $value;
    } @else if 'l' == $direction {
        margin-left: $value;
    } @else if 'v' == $direction {
        margin-top: $value;
        margin-bottom: $value;
    } @else if 'h' == $direction {
        margin-right: $value;
        margin-left: $value;
    } @else {
        margin: $value;
    }
}
